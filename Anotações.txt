IMERSÃO DADOS COM PYTHON - ALURA

Aula 1 ------------------------------------------------------------------------------------------------------------------------------------------------------------

Base de dados utilizada na imersão:
https://raw.githubusercontent.com/guilhermeonrails/data-jobs/refs/heads/main/salaries.csv

_Leitura da base de dados

Primeiramente, declaramos uma variávl para ser nossa base, como (df). Para realizar a leitura da base utilizando o pandas usamos:
df = pd.read_csv (read_csv por que nossa base está no formato csv)

Em seguida o comando (df.head()) conseguimos ver algumas linhas de nossa base.

As informações de nossa base são visualizadas em (df.info())

E uma descrição mais detalhada pode ser visualizada com o comando (df.describe())

_Dimensão

Para saber a quantidade de linhas e colunas de uma base utilizamos o comando (df.shape). Esse comando retorna uma tupla com o número de linhas e colunas.
Número de linhas [ df.shape[0] ]
Número de colunas [ df.dhape[1] ]

_Visualizar e Renomear colunas

Se quisermos visualizar as colunas da base, podemos usar o comando (df.columns).

Mas para renomear alguma criamos um dicionario com os valores antigos das colunas com os novos nomes que elas receberam. Ex:
renomear_colunas = {
    'work_year': 'ano',
    'experience_level': 'senioridade',
}

E ao final para que as alterações possam ser atribuidas as colunas da base é usado o (df.rename(columns=renomear_colunas, inplace=True))
"inplace = Aplique as alterações diretamente no objeto original, sem criar uma cópia".
"columns = Irá receber o novo dicionário com os novos valores".

_Frequência de uma categoria

Para saber a quantidade de itens em determinadas colunas usamos:
df['nome_da_coluna'].value_counts()

_Substituição de valores

Para a substituição de valores, o processo é quase identico ao de renomear. Utilizamos um dicionário para setar os novos valores para as colunas específicas,
e logo após, aplicamos as alterações.
df['nome_da_coluna'] = df['nome_da_coluna'].replace(nome_do_dicionário_criado)

Para visualizarmos o resultado:
df['nome_da_coluna'].value_counts()

_Resumo Estatístico

Para fazer um resumo estatístico apenas das colunas de texto (ou categóricas) da base de dados:
df.describe(include='object')
"object = é o tipo de dados usado pelo pandas para colunas que contêm strings".


Aula 2 ------------------------------------------------------------------------------------------------------------------------------------------------------------

LIMPEZA E PREPARAÇÃO DE DADOS

Nessa aula foi demonstrado como se utiliza a biblioteca numpy, que serve para manipulação de dados numéricos como contas matemáticas, entre outros.
Utilizamos a mesma base de dados da aula anterior e verificamos algumas questões:

_Valor nulo presente

Para identificar se existe algum valor nulo na nossa base de dados utilizamos o método (df.isnull()).
E para identificarmos a quantidade de valores nulos presentes nas colunas (df.isnull().sum()).
"sum() = soma os valores nulos, conta quantos nulos há por colunas".

_Valores Únicos

Para identificar os valores únicos da nossa base (sem repetição), é utilizado o método (unique()). 
Ex: df['work_year'].unique()

_Valores nulos

Utilizamos para filtrar e exibir somente as linhas que possuem pelo menos um valor nulo (NaN) em qualquer coluna da base.
Ex: df[df.isnull().any(axis=1)]
"df.isnull() = cria uma tabela booleana (com True) onde há valores nulos".
".any(axis=1) = verifica linha por linha (axis=1) se existe pelo menos um True (pelo menos um valor nulo naquela linha)".
"df[...] = filtra o dataframe retornando apenas as linhas onde há pelo menos um valor nulo".

_Excluir Valores nulos

Para que esses valores nulos não atrapalhem o processamento dos nossos dados, podemos realizar algumas manipulações com eles.
Para essa base de cargos de trabalho na carreira de análise de dados, foi implementado a exclusão desses valores nulos. Porque eram apenas
10 valores nulos presentes na base, e ela contam com milhares de linhas então a exclusão deles não afetaria significativamente os resultados 
da nossa análise.

Para excluir esse dados utilizamos: df.dropna()
O mais importante é não realizar a ateração diretamente na base original, criar uma outra variavel para base e realizar a alteração nessa nova variável.

_Transformação de Tipos

Muitas vezes as bases de dados possuem tipos direfentes de colunas que não são adequadas ao seu verdadeiro tipo, ou seja, a coluna de ano por exemplos 
pode estar com o tipo float64 (2025.0), e isso para algumas análises pode ser um problema. Então a transformação se faz necessária nesses casos.

Ex: df_limpo = df_limpo.assign(work_year = df_limpo['work_year'].astype(int64))

"astype(int64) = converte a coluna para o tipo inteiro 64 bits".
"assign() = retorna o novo dataframe com a coluna modificada".
"df_limpo = sobreescreve o dataframe original com a nova versão".

OBS: Se a coluna que estamos tentando converter contiver valores nulos (NaN) a conversão NÂO vai funcionar, pois NaN não pode ser convertio para inteiro.
Por isso, remover ou tratar o nulos antes.

_Criando um Dataframe

O pandas nos permite criar dataframes experimentais com python.

df_salarios = pd.DataFrame({
    'nome': ['Ana', 'Bruno', 'Carlos', 'Daniele', 'Val'],
    'salarios': [4000, np.nan, 5000, np.nan, 100000]
})

"pd.DataFrame = é o construtor da classe DataFrame".
"np.nan = nos permitr criar valore nulos, para implementarmos nas colunas da base".
A base é criada contendo linhas e colunas e seus valores são atribuido por uma lista, lembrando que para valores numéricos não utilizamos aspas.

_Preenchimento de Valores nulos

Existem várias maneiras de substitução de valores nulos, mas aqui será listado três.

1 - Preenchimento dos valores por meio de MEDIA e MEDIANA dos salários

MEDIA

df_salarios['salario_media'] = df_salarios['salário'].fillna(df_salarios['salario'].mean().round(2))

* Criamos uma nova coluna para a base (salario_media);
* Selecionamos a coluna salarios (df_salarios['salario']);
* O método fillna() substitui os valores NaN por algum valor que você passa;
* Calculamos a média dos valores na coluna 'salario' (sem contar os NaN automaticamente) [ df_salarios['salario'].mean() ];
* Arredondamos essa média para 2 casas decimais com o .round(2)
* O resultado do fillna() (coluna 'salário' com os NaN subtituídos) é atribuido à nova coluna 'salario_media';

MEDIANA

df_salarios['salario_mediana'] = df_salarios['salario'].fillna(df_salarios['salario'].median())

* Novamente selecionamos a coluna salário;
* Substituimos os valores ausente por valores específicos .fillna();
* Calculamos a mediana da coluna 'salario' (ignorando valores nulos) com .median();
* O resultado da substituição vai ser salvo na coluna 'salario_mediana'.

2 - Preenchimento por FFIL E BFILL

Criamos um novo dataframe (df_temperatura), contendo dias da semana e suas respectivas temperaturas, contendo valores ausentes.

FFILL - Foreard Fill (Preenchimento para frente)

* Faz o preenchimento do NaN com o último valor não nulo anterior na coluna.

df_temperatura['preenchimento_ffill'] = df_temperatura['temperatura'].ffill()

BFILL - Backward Fill (Preenchimento para trás)

* Preenche o Nan com o próximo valor não nulo posterior na coluna.

df_temperatura['preenchimento_bfill'] = df_temperatura['temperatura'].bfill()

"ffill() é útil para preencher dados que permanecem iguais até uma nova medição (ex: temperatura ao longo do dia)".
"bfill() pode ser útil para preencher valores faltantes no início de uma série".

OBS: É sempre bom analisar cada caso e verificar qual se adequa mais para sua solução.

3 - Substituir por Valor Fixo

Nós basicamenta vamos substituir os valores nulos por algum outro valor de nossa escolha:
Como 'Não Informado'.

Criamos um novo dataframe de cidades, onde contem o nome das pessoas e sua cidade com valores nulos.

df_cidades['cidade_preenchi'] = df_cidades['Cidade'].fillna('Não Informado')

* Seleciona a coluna 'cidade' do dataframe;
* Substitui todos os valores nulos da coluna pelo texto 'Não informado' .fillna('Não informado');
* Cria uma nova coluna com os valores preenchidos;


Aula 3 ------------------------------------------------------------------------------------------------------------------------------------------------------------

APRENDENDO UM POUCO MAIS SOBRE A CRIAÇÃO DE GRÁFICOS

Nessa aula foi apresentado as bibliotecas para visualização de dados matplotlib, seaborn e plotly.express.

Matplotlib - base para visualização em python, muitas outras utilizam ela, como a seaborn e a pandas.
_Altamente persobalizável mas muito verbosa.

Ex: 
    x = [1, 2, 3, 4]
    y = [10, 20, 25, 30]

    plt.plot(x, y)
    plt.title('Exemplo Matplotlib')
    plt.xlabel('Eixo X')
    plt.ylabel('Eixo Y')
    plt.show()

Seaborn - Sintaxe mais simples e gráficos estatisticos mais bonitos.
_Ideal para análise exploratória de dados com visual limpo e integração com pandas. Mas é menos flexível para personalizações específicas.

Ex: 
    df = pd.DataFrame({
    'categoria': ['A', 'B', 'C', 'A', 'B', 'C'],
    'valor': [10, 15, 7, 12, 14, 9]
    })

    sns.barplot(data=df, x='categoria', y='valor')

Plotly express - uma biblioteca com gráficos interativos.
_Gráficos interativos com poucos comandos. Otima para dashboards e notebooks, menos controle detalhado que o Plotly completo.

Ex:
    df = pd.DataFrame({
    'Categoria': ['A', 'B', 'C'],
    'Valor': [10, 15, 7]
    })

    fig = px.bar(df, x='Categoria', y='Valor', title='Exemplo Plotly Express')
    fig.show()

Comparação rápida:

Característica	        Matplotlib	    Seaborn	        Plotly Express
Facilidade de uso	    Média/difícil	Fácil	        Muito fácil
Estética dos gráficos	Básica	        Moderna	        Interativa e moderna
Personalização	        Alta	        Média	        Boa, mas limitada
Gráficos interativos	❌ Não	      ❌ Não	         ✅ Sim
Base	                Nativo	        Usa Matplotlib	Independente (Plotly)

PLOTANDO GRÁFICOS COM PANDAS E Matplotlib

Ex:  
    df_limpo['senioridade'].value_counts().plot(kind='bar', title='Distribuição de Senioridade')
    plt.xlabel('Senioridade')
    plt.ylabel('Quantidade')
    plt.tight_layout()
    plt.show()

* Conta quantas vezes a categora aparece na coluna de senioridade df_limpo['senioridade'].value_counts();
* Gera um gráfico de barras (kind='bar') com o titulo "Distribuição de Senioridade";
* Rótulo do eixo x (plt.xlabel(''))
* Rótulo do eixo y (plt.ylabel(''))
* Ajusta automaticamente os espaçamentos entre os elementos do gráfico para evitar sobreposição;
* Plota o gráfico (plt.show()).

PLOTANDO GRÁFICO COM SEABORN 

Ex: 
    plt.figure(figsize=(8, 5))
    sns.barplot(data=df_limpo, x='senioridade', y='usd') 
    plt.title('Media Mensal de Senioridade')
    plt.xlabel('Senioridade')
    plt.ylabel('Salario Médio Anual (USD)')
    plt.tight_layout()
    plt.show()

* Declaramos a altura e largura da figura ( plt.figure(figsize(largura, altura)) );
* data=df_limpo é o dataframe que contem os dados;
* x='senioridade' y='usd', o que cada eixo irá mostrar;
* plt.title('') é onde declaramos o título do gráfico.

ORDENANDO A EXIBIÇÃO DO GRÁFICO 

Ex: 
    ordem = df_limpo.groupby('senioridade')['usd'].mean().sort_values(ascending=False).index

    plt.figure(figsize=(8, 5))
    sns.barplot(data=df_limpo, x='senioridade', y='usd', order=ordem)
    plt.title("Média Mensal de Senioridade")
    plt.xlabel("Senioridade")
    plt.ylabel("Salário Médio Anual (USD)")
    plt.tight_layout()
    plt.show()

* Agrupamos os dados pela coluna senioridade e calculamos a média dos salários para cada nível de senioridade;
* Ordena os valores médios do maior para o menor .sort_values(ascending=False)
* Pega apenas os nomes das categorias (nível de senioridade), na ordem da média salarial decrescente .index.


HISTOGRAMA

Ex: 
    plt.figure(figsize=(10, 5))
    sns.histplot(df_limpo['usd'], bins=50, kde=True)
    plt.title('Distribuição dos Salários Anuais')
    plt.xlabel('Salário em USD')
    plt.ylabel('Frequência')
    plt.tight_layout()
    plt.show()

* sns.histplot() cria um histograma que mostra a distribuição dos dados numéricos;
* Os dados que seram plotados são somente os salários ['usd'];
* O histograma será dividido em 50 fixas (intervalos) - (bins=50) -> mais bins = mais detalhamento;
* Adiciona uma curva KDE (Kernel Density Estimation) por cima do histograma, que mostra uma estimativa suave da distribuição dos dados.

BOXPLOT

Ex: 
    plt.figure(figsize=(8, 5))
    sns.boxplot(x=df_limpo['usd'])
    plt.title('Boxplot Salário')
    plt.xlabel('Salário em USD')
    plt.tight_layout()
    plt.show()

* sns.boxplot plota o gráfico de boxplot da variável salário ['usd'].

BOXPLOT DA SENIORIDADE E SALÁRIO 

Ex: 
    ordem_senioridade = ['Junior', 'Pleno', 'Senior', 'Executivo']

    plt.figure(figsize=(8, 5))
    sns.boxplot(x='senioridade', y='usd', data=df_limpo, order=ordem_senioridade, palette='Set2', hue='senioridade')
    plt.title('Distiubuição por Senioridade')
    plt.xlabel('Salário em USD')
    plt.tight_layout()
    plt.show()

* O gráfico será plotado levando em consideração a ordem de senioridade;
* 'order' ordena os grupos do eixo x conforme a lista passada;
* palette='Set2' define uma paleta de cores suave e colorida;
* hue='senioridade' adiciona uma cor diferente para cada categoria de senioridade, complementando o comando palette.

GRÁFICOS INTERATIVOS COM PLOTLY

Ex: 
    senioridade_media_salario = df_limpo.groupby('senioridade')['usd'].mean().sort_values(ascending=False).reset_index()
    fig = px.bar(senioridade_media_salario,
                x='senioridade',
                y='usd',
                title='Média Salarial por Senioridade',
                labels={'senioridade': 'Nível de Senioridade', 'usd': 'Média Salarial Anual (USD)'})
    fig.show()

* Agrupa os dados pela coluna senioridade df_limpo.groupby('senioridade')['usd'].mean(), calculando a média do salário para cada grupo;
* Ordena os resultados da média de forma decrescente .sort_values(ascending=False);
* Transforma o resultado da série agrupada de volta em um dataframe padrão, com os índices reiniciados .reset_index().
* px.bar gráfico de barras, passando o dataframe base - as colunas que pertence a cada eixo - titulo - e os rótulos dos eixos.
* fig.show() plota o gráfico.

GRÁFICO DE PIZZA COM PLOTLY

Ex:

    remoto_contagem = df_limpo['remoto'].value_counts().reset_index()
    remoto_contagem.columns = ['tipo_trabalho', 'quantidade']

    fig = px.pie(remoto_contagem,
                names='tipo_trabalho',
                values='quantidade',
                title='Proporção dos Tipos de Trabalho',
                )
    fig.show()

* Conta quantas vezes cada categoria da coluna remoto aparece e transforma essa contagem em um dataframe para facilitar o uso em gráficos.
* Seleciona as colunas que queremos;
* px.pie cria o gráfico de PIZZA;
* names = define o nomde da cada fatia da pizza com base nas categorias;
* values = define o tamanho de cada fatia com base no número de ocorrências.

GRÁFICO DE ROSCA COM PLOTLY

Ex: 
    remoto_contagem = df_limpo['remoto'].value_counts().reset_index()
    remoto_contagem.columns = ['tipo_trabalho', 'quantidade']

    fig = px.pie(remoto_contagem,
                names='tipo_trabalho',
                values='quantidade',
                title='Proporção dos Tipos de Trabalho',
                hole=0.5
                )
    fig.update_traces(textinfo='percent+label')
    fig.show()

* hole=0.5 transforma o gráfico de pizza em rosca (50% de buraco no centro);
* fig.update_traces(textinfo='percent+label') adiciona um rótulo mais porcentagem.

Aula 4 ------------------------------------------------------------------------------------------------------------------------------------------------------

Uau, essa aula foi repleta de novidades, uma delas foi a criação de um dashboard super interativo com 
a biblioteca streamlit.

STREAMLIT

_Streamlit é uma biblioteca python de código abreto que permite criar dashboards e aplicações qeb interativas com extrema facilidade, sem precisar escrever html, css ou javascript.

* Permite criar interfaces gráficas com python puro.
* Ideal para protótipos rápidos, visualizações de dados, dashboards interativos e apresentações.
* Integra facilmente com pandas, plotly, matplotlib, sklearn, tensorflow.
* Interface simples baseada em componentes reativos (widgets, gráficos, tabelas...).

RODAR A APLICAÇÃO

Para rodar a aplicação basta executar o comando: streamlit run nome_aplicação.py

COMPONENTES DA CONSTRUÇÃO DO DASHBOARD
____________________________________________________________________________________________________________________________________________________
COMPONENTE                  |CÓDIGO                      |DESCRIÇÃO
____________________________________________________________________________________________________________________________________________________                            |                            |
Configuração da página      |st.set_page_config(...)     |Define o título da aba, ícone e layout da página para ocupar toda a largura.
____________________________________________________________________________________________________________________________________________________
Título principal            |st.title(...)               |Cria um titulo grande no topo do dashboard.
____________________________________________________________________________________________________________________________________________________
Texto explicativo           |st.markdown(...)            |Adiciona texto formatado com markdown (descrição, separadores, etc).
____________________________________________________________________________________________________________________________________________________
Cabeçalho lateral           |st.sidebar.header(...)      |Adiciona um título na barra lateral para agrupar os filtros para agrupar os filtros.
____________________________________________________________________________________________________________________________________________________
Filtro multiplo             |st.sidebar.multiselect(...) |Permite selecionar múltiplas opções em filtros (ano, senioridade, contrato, empresa).
____________________________________________________________________________________________________________________________________________________
DataFrame filtrado          |df[...] com isin(...)       |Filtra os dados com base nos filtros escolhidos pelo usuário.
____________________________________________________________________________________________________________________________________________________
Métricas resumidas (KPI)    |st.metric(...)              |Exibe valores principais como salário médio, máximo, número de registros, cargo mais comum.
____________________________________________________________________________________________________________________________________________________
Layout em colunas           |st.columns(n)               |Divide o layout em n colunas. Usado para kpis e gráficos lado a lado.
____________________________________________________________________________________________________________________________________________________
Gráficos com Plotly         |px.bar, px.histogram,       |Cria gráficos interativos: barras, histograma, pizza, mapa, coroplético.
                            |px.pie, px.choropleth                             
____________________________________________________________________________________________________________________________________________________
Exibir gráficos no app      |st.plotly_chart(...)        |Insere o gráfico Plotly no dashboard. Com 'use_container_width=True' para responsividade.
____________________________________________________________________________________________________________________________________________________
Mensagem de aviso           |st.warning(...)             |Mostra um alerta amigável se o filtro não retornar dados.
____________________________________________________________________________________________________________________________________________________
Tabela de dados final       |st.dataframe(...)           |Mostra o dataframe final, já fltrado, em formato interativo.
____________________________________________________________________________________________________________________________________________________

Os filtros reagem em tempo real e o df_filtrado contem somento os dados escolhidos.

* isin() verifica se cada valor da linha está dentro da seleção do usuário.

FILTROS 

* Obtém as opções únicas diretamente do dataframe df['coluna'].unique()
* Cria o filtro na barra lateral com multiselect(...)
* Filtra o DataFrame principal usando os valores selecionados.
  (Aqui o .isin(...) verifica se cada valor da linha está dentro da seleção do usuário).

Ex: 
    #Filtro de Ano
    anos_disponíveis = sorted(df['ano'].unique())
    anos_selecionados = st.sidebar.multiselect("Ano", anos_disponíveis, default=anos_disponíveis)

    #Filtro de senioridade
    senioridades_disponíveis = sorted(df['senioridade'].unique())
    senioridades_selecionadas = st.sidebar.multiselect("Senioridade", senioridades_disponíveis, default=senioridades_disponíveis)

    #Filtro por tipo de contrato
    contratos_disponiveis = sorted(df['contrato'].unique())
    contratos_selecionados = st.sidebar.multiselect("Tipo de Contrato", contratos_disponiveis, default=contratos_disponiveis)

    #Filtro por tamanho da empresa
    tamanhos_disponíveis = sorted(df['tamanho_empresa'].unique())
    tamanhos_selecionados = st.sidebar.multiselect("Tamanho da Empresa", tamanhos_disponíveis, default=tamanhos_disponíveis)

    #Filtragem do dataframe
    #O dataframe proncipal é filtrado com base nas seleções feitas na barra lateral
    df_filtrado = df[
        (df['ano'].isin(anos_selecionados)) &
        (df['senioridade'].isin(senioridades_selecionadas)) &
        (df['contrato'].isin(contratos_selecionados)) &
        (df['tamanho_empresa'].isin(tamanhos_selecionados))
    ]

MÉTRICAS PRINCIPAIS 

São plotadas 4 métricas principais: salario_medio, salario_maximo, total_registros, cargo_mais_frequente.

.mode()[0] - retorna o valor mais frequente de uma série ou coluna, e o 0 seleciona o primeiro valor retornado, caso haja mais de um valor com a mesma frequencia máxima.
df_filtrado.shape[0] - retorna apenas o número de linhas.
_Se não tiver dados o else aribuirá valores zerados e vazios.

Logo mais as métricas seram setadas usando o .metric(titulo, variável)

GRÁFICOS

Foram construídos 4 gráficos: barras, histograma, pizza e mapa.

-Barras 

| Linha | Código                                                      | O que faz                                                                                              |
| ----- | ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| 1     | `with col_graf1:`                                           | Usa o layout em coluna do Streamlit para colocar esse gráfico à esquerda.                              |
| 2     | `if not df_filtrado.empty:`                                 | Verifica se há dados após os filtros; evita erro ao tentar gerar gráficos com DataFrame vazio.         |
| 3     | `top_cargos = df_filtrado.groupby('cargo')['usd'].mean()`   | Agrupa o DataFrame por cargo e calcula a **média salarial** (`usd`) de cada cargo.                     |
| 4     | `.nlargest(10)`                                             | Pega os **10 cargos com maior média salarial**.                                                        |
| 5     | `.sort_values(ascending=True)`                              | Reordena os dados do menor para o maior (para gráfico horizontal mais intuitivo).                      |
| 6     | `.reset_index()`                                            | Reorganiza o índice após o agrupamento, tornando `cargo` uma coluna normal novamente.                  |
| 7     | `grafico_cargos = px.bar(...)`                              | Cria um **gráfico de barras horizontal** com Plotly Express, onde:                                     |
|       | `x='usd'`, `y='cargo'`                                      | `x`: valor do salário médio, `y`: nome do cargo.                                                       |
|       | `orientation='h'`                                           | Torna o gráfico **horizontal**.                                                                        |
|       | `title=...`, `labels=...`                                   | Define título e rótulos amigáveis para os eixos.                                                       |
| 8     | `grafico_cargos.update_layout(...)`                         | Centraliza o título (`title_x=0.1`) e define a ordem do eixo y com base nos valores (`categoryorder`). |
| 9     | `st.plotly_chart(grafico_cargos, use_container_width=True)` | Exibe o gráfico no app, adaptando à largura da coluna.                                                 |
| 10    | `else: st.warning(...)`                                     | Se o `df_filtrado` estiver vazio, exibe uma mensagem de aviso ao usuário.                              |

-Histograma 
 
| Parâmetro                                 | Valor                   | O que faz                                                          |
| ----------------------------------------- | ----------------------- | ------------------------------------------------------------------ |
| `df_filtrado`                             | DataFrame filtrado      | Usa apenas os dados com base nos filtros.                          |
| `x='usd'`                                 | Coluna de salário anual | Plota os salários no eixo X (faixas salariais).                    |
| `nbins=30`                                | 30 faixas (barras)      | Define o número de **intervalos (bins)** para agrupar os salários. |
| `title="Distribuição de salários anuais"` | Título do gráfico       | Aparece centralizado no topo.                                      |
| `labels={...}`                            | Rótulos personalizados  | Muda os nomes dos eixos para legibilidade.                         |

-Pizza 

| Linha | Código                                                                 | O que faz                                                                                  |
| ----- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| 1     | `with col_graf3:`                                                      | Insere o conteúdo na **terceira coluna** da seção de gráficos.                             |
| 2     | `if not df_filtrado.empty:`                                            | Verifica se o DataFrame tem dados (após os filtros aplicados).                             |
| 3     | `remoto_contagem = df_filtrado['remoto'].value_counts().reset_index()` | Conta quantos registros existem para cada tipo de trabalho (`remoto`, `presencial`, etc.). |
| 4     | `remoto_contagem.columns = ['tipo_trabalho', 'quantidade']`            | Renomeia as colunas para nomes mais legíveis no gráfico.     
                              |
| Parâmetro  | Valor                               | Significado                                                        |
| ---------- | ----------------------------------- | ------------------------------------------------------------------ |
| `names`    | `'tipo_trabalho'`                   | Define os **rótulos** das fatias do gráfico.                       |
| `values`   | `'quantidade'`                      | Define o **tamanho** de cada fatia com base na quantidade.         |
| `hole=0.5` | 0.5                                 | Cria um **gráfico de rosca (donut)** ao invés de uma pizza sólida. |
| `title`    | `'Proporção dos tipos de trabalho'` | Título centralizado do gráfico.                                    |

* Exibe tanto o percentual quanto o rótulo da fatia. (grafico_remoto.update_traces(textinfo='percent+label'))
* Centraliza levemente o titulo no topo do grafico. (grafico_remoto.update_layout(title_x=0.1))

-Mapa 

| Parâmetro                         | Descrição                                                                     |
| --------------------------------- | ----------------------------------------------------------------------------- |
| `locations='residencia_iso3'`     | Espera códigos de país no padrão ISO 3166-1 alpha-3.                          |
| `color='usd'`                     | Usado para preencher a cor do país baseado no valor salarial.                 |
| `color_continuous_scale='rdylgn'` | Escala de cor contínua do vermelho (valores baixos) ao verde (valores altos). |
| `labels`                          | Altera os rótulos exibidos no gráfico.                                        |

* Cria um novo dataframe apenas com registros onde o cargo e data scientist.
* Agrupa os dados por pais de residencia (residencia_iso3) e calcula a média salarial para cientista de dados em cada pais.
* Alerta o usuário se nenhum dado estiver disponível para renderizar o mapa.

Por fim mostramos uma tabela do nosso dataframe filtrado pelo usuário.
